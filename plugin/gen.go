package plugin

import (
	"fmt"
	"path/filepath"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protodesc"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func Gen(j *HttpJsonGen, f *descriptorpb.FileDescriptorProto) error {
	if j.ts.ImportTsProtoPackageName == "" {
		j.ts.ImportTsProtoPackageName = "pb"
	}
	if j.ts.ResponseTypeName == "" {
		j.ts.ResponseTypeName = "GrpcGatewayResponse"
	}
	if j.ts.ResponseTypeStruct == "" {
		j.ts.ResponseTypeStruct = "{data: any}"
	}
	if j.suffix == "" {
		j.suffix = "httpjson"
	}

	file, err := genFile(j.suffix, f)
	if err != nil {
		return err
	}

	return render(j, file)
}

func genFile(suffix string, f *descriptorpb.FileDescriptorProto) (*File, error) {
	filePkg = *f.Package

	protoFileDir := filepath.ToSlash(filepath.Dir(*f.Name))
	protoFileName := filepath.Base(filepath.ToSlash(strings.TrimSuffix(*f.Name, ".proto")))
	genFileName := filepath.Join(protoFileDir, fmt.Sprintf("%s_%s.ts", protoFileName, suffix))

	g := &GeneratedFile{
		filePath:         *f.Name,
		fileName:         protoFileName,
		packageNames:     make(map[string]string),
		usedPackageNames: make(map[string]bool),
		manualImports:    make(map[string]bool),
		resultFileName:   genFileName,
	}

	desc, err := protodesc.NewFile(f, fileReg)
	if err != nil {
		return nil, fmt.Errorf("invalid FileDescriptorProto %q: %v", f.GetName(), err)
	}
	if err := fileReg.RegisterFile(desc); err != nil {
		return nil, fmt.Errorf("cannot register descriptor %q: %v", f.GetName(), err)
	}

	return &File{
		Desc:  desc,
		Proto: f,
		gen:   g,
	}, nil
}

func render(j *HttpJsonGen, f *File) error {
	if f.Desc.Services().Len() == 0 {
		return nil
	}

	importPkg = make(map[string]PkgInfo)

	g := f.gen
	g.P()
	g.P()

	g.P("// Code generated by protoc-gen-" + j.suffix + ". DO NOT EDIT.")
	g.P("// - protoc             ", protocVersionV2(j.req))

	g.P("// source: ", g.filePath)

	g.P()
	g.P()
	// import ts-proto generate file
	g.P(`import * as ` + j.ts.ImportTsProtoPackageName + ` from "./` + f.gen.fileName + "\";")
	g.P(`import type * as ` + j.ts.ImportTsProtoPackageName + `type from "./` + f.gen.fileName + "\";")

	for i := 0; i < f.Desc.Imports().Len(); i++ {
		pkgName := string(f.Desc.Imports().Get(i).FileDescriptor.Package())
		importPkg[pkgName] = PkgInfo{
			PkgName: pkgName,
			PkgPath: filepath.ToSlash(strings.TrimSuffix(string(f.Desc.Imports().Get(i).FileDescriptor.Path()), ".proto")),
			Prefix:  strings.ReplaceAll(pkgName, ".", ""),
		}
	}

	genPathDeepStr := func(protoPath string) string {
		pathDeep := strings.Count(filepath.ToSlash(protoPath), "/")
		if pathDeep == 0 {
			return "./"
		}
		var p []string
		for i := 0; i < pathDeep; i++ {
			p = append(p, "..")
		}
		return filepath.Join(p...)
	}

	for i := 0; i < f.Desc.Services().Len(); i++ {
		services := f.Desc.Services().Get(i)
		for ii := 0; ii < services.Methods().Len(); ii++ {
			method := services.Methods().Get(ii)
			pkgName := strings.TrimSuffix(string(method.Input().FullName()), "."+string(method.Input().Name()))
			importPkgFaileds[pkgName] = append(importPkgFaileds[pkgName], method.Input())
		}
	}

	for pkgName, info := range importPkg {
		if len(importPkgFaileds[pkgName]) == 0 {
			continue
		}

		var pkgTypes []string
		for _, v := range importPkgFaileds[pkgName] {
			pkgTypes = append(pkgTypes, fmt.Sprintf("%s as %s", string(v.Name()), j.ts.getInputName(v)))
		}
		g.P(`import { ` + strings.Join(pkgTypes, ", ") + ` } from "` + filepath.Join(genPathDeepStr(*f.Proto.Name), info.PkgPath) + "\";")
	}

	g.P()
	g.P("export type " + j.ts.ResponseTypeName + " = {")
	g.P(strings.TrimSpace(strings.TrimSuffix(strings.TrimPrefix(j.ts.ResponseTypeStruct, "{"), "}")))
	g.P("}")
	g.P()
	g.P(`
type CallHandler<T> = (
    path: string,
    body: any,
    cfg?: T,
) => Promise<` + j.ts.ResponseTypeName + `>;

export interface CallOptions<T> {
    handler?: CallHandler<T>;
    cfg?: T;
}

// for example of axios: 
//
// async function handler(
//     path: string,
//	   body: any,
//	   cfg?: AxiosRequestConfig,
// ): Promise<` + j.ts.ResponseTypeName + `> {
//	   const resp = await axios.post(path, body, cfg);
//	   return resp.data as ` + j.ts.ResponseTypeName + `;
// }
// 
// const client = new XxxClient(handler);
	`)

	for i := 0; i < f.Desc.Services().Len(); i++ {
		service := f.Desc.Services().Get(i)
		j.generateClass(f.gen, service)
	}

	j.generatedFile = append(j.generatedFile, f)

	return nil
}

func (j *HttpJsonGen) generateClass(g *GeneratedFile, service protoreflect.ServiceDescriptor) {
	className := service.Name() + "Client"
	g.P()
	g.P(`
export class ` + className + `<T> {

    	private _baseURL: string;
		private _handler: CallHandler<T>;

		constructor(handler: CallHandler<T>, baseURL?: string) {
			if (baseURL !== undefined && baseURL.substring(baseURL.length - 1, baseURL.length) === '/') {
				baseURL = baseURL.substring(0, baseURL.length - 1)
			}
			this._handler = handler;
			this._baseURL = baseURL || '';
		}
	`)
	g.P()

	for ii := 0; ii < service.Methods().Len(); ii++ {
		method := service.Methods().Get(ii)
		if !method.IsStreamingServer() && !method.IsStreamingClient() {
			j.generateClassMethod(g, service, method)
		} else {
			g.P("	// " + method.Name() + " is not support")
		}
	}

	g.P("}")
	g.P()
}

func (j *HttpJsonGen) generateClassMethod(g *GeneratedFile, service protoreflect.ServiceDescriptor, method protoreflect.MethodDescriptor) {
	gwi := func(i ...interface{}) {
		var a = []interface{}{"    "}
		a = append(a, i...)
		g.P(a...)
	}

	gwi("async "+string(method.Name())+"(req: ", j.ts.getInputName(method.Input()), ", callOptions?: CallOptions<T>): Promise<"+j.ts.ImportTsProtoPackageName+"."+string(method.Output().Name())+"> {")
	gwi("    const resp = await this._handler(this._baseURL + '" + formatFullMethodName(service, method) + "', req, callOptions?.cfg)")
	gwi("    if (!resp.meta || resp.meta.code === undefined || resp.meta.message === undefined) {")
	gwi("        throw new Error('unknown response type');")
	gwi("    }")
	gwi("    if (resp.meta.code !== 0) {")
	gwi("        throw new Error(resp.meta.message);")
	gwi("    }")
	gwi("    return " + j.ts.getInputName(method.Output()) + ".fromJSON(resp.data)")
	gwi("}")
	gwi()
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func formatFullMethodName(service protoreflect.ServiceDescriptor, method protoreflect.MethodDescriptor) string {
	return fmt.Sprintf("/%s/%s", service.FullName(), method.Name())
}

func protocVersionV2(req *pluginpb.CodeGeneratorRequest) string {
	v := req.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func (s *HttpJsonGen) Response() *pluginpb.CodeGeneratorResponse {
	resp := new(pluginpb.CodeGeneratorResponse)

	for _, v := range s.generatedFile {
		content := v.gen.buf.Bytes()

		resp.File = append(resp.File, &pluginpb.CodeGeneratorResponse_File{
			Name:    proto.String(v.gen.resultFileName),
			Content: proto.String(string(content)),
		})
	}

	v3 := uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
	resp.SupportedFeatures = &v3
	return resp
}
